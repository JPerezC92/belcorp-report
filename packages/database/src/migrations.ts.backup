import type { Database } from "sql.js";
import { TABLE_NAMES } from "./table-names.js";

/**
 * Database migration interface with enhanced features
 */
export interface Migration {
	version: string;
	description: string;
	dependencies?: string[]; // Versions this migration depends on
	up: (db: Database) => void | Promise<void>;
	down?: (db: Database) => void | Promise<void>;
	checksum?: string; // For integrity validation
	applied?: Date;
}

/**
 * Migration execution result
 */
export interface MigrationResult {
	version: string;
	success: boolean;
	error?: Error;
	executionTime: number;
}

/**
 * Migration state information
 */
export interface MigrationState {
	version: string;
	description: string;
	applied_at: string;
	checksum: string | null;
}

/**
 * Migration error class for better error handling
 */
export class MigrationError extends Error {
	constructor(
		message: string,
		public readonly version: string,
		public readonly operation: "up" | "down",
		public readonly originalError?: Error
	) {
		super(message);
		this.name = "MigrationError";

		if (originalError) {
			this.stack = `${this.stack}\nCaused by: ${originalError.stack}`;
		}
	}
}

/**
 * Generate a simple checksum for migration validation
 */
function generateChecksum(migration: Migration): string {
	const content =
		migration.up.toString() + (migration.down?.toString() || "");
	let hash = 0;
	for (let i = 0; i < content.length; i++) {
		const char = content.charCodeAt(i);
		hash = (hash << 5) - hash + char;
		hash = hash & hash; // Convert to 32-bit integer
	}
	return Math.abs(hash).toString(16);
}

/**
 * Available migrations with enhanced structure
 */
export const migrations: Migration[] = [
	{
		version: "001",
		description: "Initialize database with all tables and default data",
		up: (db: Database) => {
			// ===== TABLE 1: TAG =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.TAG} (
					requestId TEXT PRIMARY KEY,
					createdTime TEXT,
					requestIdLink TEXT,
					informacionAdicional TEXT,
					modulo TEXT,
					problemId TEXT,
					problemIdLink TEXT,
					linkedRequestIdValue TEXT,
					linkedRequestIdLink TEXT,
					jira TEXT,
					categorizacion TEXT,
					technician TEXT,
					processedAt TEXT DEFAULT CURRENT_TIMESTAMP
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_tag_createdTime ON ${TABLE_NAMES.TAG}(createdTime)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_tag_technician ON ${TABLE_NAMES.TAG}(technician)`);

			// ===== TABLE 2: FOR_TAGGING_DATA (with link columns from migration 006) =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.FOR_TAGGING_DATA} (
					requestId TEXT PRIMARY KEY,
					technician TEXT,
					createdTime TEXT,
					modulo TEXT,
					subject TEXT,
					problemId TEXT,
					linkedRequestId TEXT,
					category TEXT,
					importedAt TEXT DEFAULT CURRENT_TIMESTAMP,
					sourceFile TEXT,
					requestIdLink TEXT,
					subjectLink TEXT,
					problemIdLink TEXT,
					linkedRequestIdLink TEXT
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_for_tagging_data_category ON ${TABLE_NAMES.FOR_TAGGING_DATA}(category)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_for_tagging_data_technician ON ${TABLE_NAMES.FOR_TAGGING_DATA}(technician)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_for_tagging_data_createdTime ON ${TABLE_NAMES.FOR_TAGGING_DATA}(createdTime)`);

			// ===== TABLE 3: PARENT_CHILD_RELATIONSHIPS =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.PARENT_CHILD_RELATIONSHIPS} (
					parentRequestId TEXT NOT NULL,
					parentLink TEXT,
					childRequestId TEXT NOT NULL,
					childLink TEXT,
					createdAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
					updatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
					PRIMARY KEY (parentRequestId, childRequestId)
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_parent_child_parentRequestId ON ${TABLE_NAMES.PARENT_CHILD_RELATIONSHIPS}(parentRequestId)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_parent_child_childRequestId ON ${TABLE_NAMES.PARENT_CHILD_RELATIONSHIPS}(childRequestId)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_parent_child_createdAt ON ${TABLE_NAMES.PARENT_CHILD_RELATIONSHIPS}(createdAt)`);

			// ===== TABLE 4: CORRECTIVE_MAINTENANCE_RECORDS (with businessUnit and inDateRange) =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS} (
					requestId TEXT PRIMARY KEY,
					requestIdLink TEXT,
					createdTime TEXT NOT NULL,
					applications TEXT NOT NULL,
					categorization TEXT NOT NULL,
					requestStatus TEXT NOT NULL,
					module TEXT NOT NULL,
					subject TEXT NOT NULL,
					subjectLink TEXT,
					priority TEXT NOT NULL,
					eta TEXT NOT NULL,
					rca TEXT NOT NULL,
					businessUnit TEXT NOT NULL DEFAULT 'Unknown',
					inDateRange BOOLEAN DEFAULT 0,
					createdAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
					updatedAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_corrective_maintenance_requestId ON ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS}(requestId)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_corrective_maintenance_module ON ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS}(module)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_corrective_maintenance_createdTime ON ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS}(createdTime)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_corrective_maintenance_requestStatus ON ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS}(requestStatus)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_corrective_maintenance_businessUnit ON ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS}(businessUnit)`);

			// ===== TABLE 5: MONTHLY_REPORT_RECORDS (with inDateRange renamed from semanal) =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.MONTHLY_REPORT_RECORDS} (
					requestId TEXT PRIMARY KEY,
					applications TEXT NOT NULL,
					categorization TEXT,
					requestIdLink TEXT,
					createdTime TEXT NOT NULL,
					requestStatus TEXT NOT NULL,
					module TEXT NOT NULL,
					subject TEXT NOT NULL,
					subjectLink TEXT,
					priority TEXT,
					eta TEXT,
					additionalInfo TEXT,
					resolvedTime TEXT,
					affectedCountries TEXT,
					recurrence TEXT,
					technician TEXT,
					jira TEXT,
					problemId TEXT,
					problemIdLink TEXT,
					linkedRequestId TEXT,
					linkedRequestIdLink TEXT,
					requestOLAStatus TEXT,
					escalationGroup TEXT,
					affectedApplications TEXT,
					shouldResolveLevel1 TEXT,
					campaign TEXT,
					cuv1 TEXT,
					release TEXT,
					rca TEXT,
					businessUnit TEXT NOT NULL,
					inDateRange BOOLEAN DEFAULT 0,
					rep TEXT NOT NULL,
					dia INTEGER NOT NULL,
					week INTEGER NOT NULL,
					priorityReporte TEXT,
					requestStatusReporte TEXT NOT NULL,
					informacionAdicionalReporte TEXT,
					enlaces INTEGER DEFAULT 0,
					mensaje TEXT,
					statusModifiedByUser BOOLEAN DEFAULT 0,
					createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
					updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_requestId ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(requestId)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_applications ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(applications)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_module ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(module)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_createdTime ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(createdTime)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_requestStatus ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(requestStatus)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_businessUnit ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(businessUnit)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_rep ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(rep)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_semanal ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(inDateRange)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_week ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(week)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_linkedRequestId ON ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}(linkedRequestId)`);

			// ===== TABLE 6: DATE_RANGE_CONFIGS (with rangeType and scope from migration 014) =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.DATE_RANGE_CONFIGS} (
					id INTEGER PRIMARY KEY AUTOINCREMENT,
					fromDate TEXT NOT NULL,
					toDate TEXT NOT NULL,
					description TEXT NOT NULL,
					isActive BOOLEAN DEFAULT 1,
					rangeType TEXT CHECK(rangeType IN ('weekly', 'custom', 'disabled')) DEFAULT 'disabled',
					scope TEXT CHECK(scope IN ('monthly', 'corrective', 'global')) DEFAULT 'monthly',
					createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
					updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_date_range_configs_active ON ${TABLE_NAMES.DATE_RANGE_CONFIGS}(isActive)`);

			// Insert 3 default date range configs (all disabled)
			db.run(`
				INSERT INTO ${TABLE_NAMES.DATE_RANGE_CONFIGS}
					(fromDate, toDate, description, isActive, rangeType, scope, createdAt, updatedAt)
				VALUES
					('2025-01-01', '2025-12-31', 'Monthly Range (Disabled)', 1, 'disabled', 'monthly', datetime('now'), datetime('now')),
					('2025-01-01', '2025-12-31', 'Corrective Range (Disabled)', 1, 'disabled', 'corrective', datetime('now'), datetime('now')),
					('2025-01-01', '2025-12-31', 'Global Range (Disabled)', 1, 'disabled', 'global', datetime('now'), datetime('now'))
			`);

			// ===== TABLE 7: DATE_RANGE_SETTINGS =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.DATE_RANGE_SETTINGS} (
					id INTEGER PRIMARY KEY CHECK(id = 1),
					globalModeEnabled INTEGER DEFAULT 0,
					createdAt TEXT NOT NULL,
					updatedAt TEXT NOT NULL
				)
			`);
			db.run(`
				INSERT INTO ${TABLE_NAMES.DATE_RANGE_SETTINGS} (id, globalModeEnabled, createdAt, updatedAt)
				VALUES (1, 0, datetime('now'), datetime('now'))
			`);

			// ===== TABLE 8: BUSINESS_UNIT_RULES =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.BUSINESS_UNIT_RULES} (
					id INTEGER PRIMARY KEY AUTOINCREMENT,
					business_unit TEXT NOT NULL,
					pattern TEXT NOT NULL,
					pattern_type TEXT CHECK(pattern_type IN ('contains', 'regex', 'exact')) DEFAULT 'contains',
					priority INTEGER DEFAULT 0,
					active BOOLEAN DEFAULT 1,
					created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
					updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_business_unit_rules_business_unit ON ${TABLE_NAMES.BUSINESS_UNIT_RULES}(business_unit)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_business_unit_rules_active ON ${TABLE_NAMES.BUSINESS_UNIT_RULES}(active)`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_business_unit_rules_priority ON ${TABLE_NAMES.BUSINESS_UNIT_RULES}(priority)`);

			// Insert default business unit rules
			const defaultRules = [
				{ businessUnit: 'FFVV', pattern: 'APP - Gestiona tu Negocio (SE)', priority: 1 },
				{ businessUnit: 'FFVV', pattern: 'APP - Crecer es Ganar (FFVV)', priority: 2 },
				{ businessUnit: 'FFVV', pattern: 'Portal FFVV', priority: 3 },
				{ businessUnit: 'SB', pattern: 'Somos Belcorp 2.0', priority: 4 },
				{ businessUnit: 'SB', pattern: 'APP - SOMOS BELCORP', priority: 5 },
				{ businessUnit: 'UB-3', pattern: 'Unete 3.0', priority: 6 },
				{ businessUnit: 'UN-2', pattern: 'Unete 2.0', priority: 7 },
				{ businessUnit: 'CD', pattern: 'Catálogo Digital', priority: 8 },
				{ businessUnit: 'PROL', pattern: 'PROL', priority: 9 }
			];
			const insertStmt = db.prepare(`
				INSERT INTO ${TABLE_NAMES.BUSINESS_UNIT_RULES}
				(business_unit, pattern, pattern_type, priority, active, created_at, updated_at)
				VALUES (?, ?, 'contains', ?, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
			`);
			try {
				defaultRules.forEach((rule) => {
					insertStmt.run([rule.businessUnit, rule.pattern, rule.priority]);
				});
			} finally {
				insertStmt.free();
			}

			// ===== TABLE 9: MONTHLY_REPORT_STATUS_MAPPING_RULES =====
			db.run(`
				CREATE TABLE IF NOT EXISTS ${TABLE_NAMES.MONTHLY_REPORT_STATUS_MAPPING_RULES} (
					id INTEGER PRIMARY KEY AUTOINCREMENT,
					sourceStatus TEXT NOT NULL,
					targetStatus TEXT NOT NULL,
					patternType TEXT CHECK(patternType IN ('exact', 'contains', 'regex')) DEFAULT 'exact',
					priority INTEGER NOT NULL,
					active INTEGER NOT NULL DEFAULT 1,
					createdAt TEXT NOT NULL,
					updatedAt TEXT NOT NULL
				)
			`);
			db.run(`CREATE INDEX IF NOT EXISTS idx_monthly_report_status_mapping_priority ON ${TABLE_NAMES.MONTHLY_REPORT_STATUS_MAPPING_RULES}(priority, active)`);

			// Insert default status mappings
			db.run(`
				INSERT INTO ${TABLE_NAMES.MONTHLY_REPORT_STATUS_MAPPING_RULES}
					(sourceStatus, targetStatus, patternType, priority, active, createdAt, updatedAt)
				VALUES
					('En Mantenimiento Correctivo', 'In L3 Backlog', 'exact', 10, 1, datetime('now'), datetime('now')),
					('Dev in Progress', 'In L3 Backlog', 'exact', 11, 1, datetime('now'), datetime('now')),
					('Nivel 2', 'On going in L2', 'exact', 20, 1, datetime('now'), datetime('now')),
					('Nivel 3', 'On going in L3', 'exact', 30, 1, datetime('now'), datetime('now')),
					('Validado', 'Closed', 'exact', 40, 1, datetime('now'), datetime('now')),
					('Closed', 'Closed', 'exact', 41, 1, datetime('now'), datetime('now'))
			`);

			console.log('✅ Database initialized with all tables and default data');
		},
		down: (db: Database) => {
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.TAG}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.FOR_TAGGING_DATA}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.PARENT_CHILD_RELATIONSHIPS}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.CORRECTIVE_MAINTENANCE_RECORDS}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.MONTHLY_REPORT_RECORDS}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.DATE_RANGE_CONFIGS}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.DATE_RANGE_SETTINGS}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.BUSINESS_UNIT_RULES}`);
			db.run(`DROP TABLE IF EXISTS ${TABLE_NAMES.MONTHLY_REPORT_STATUS_MAPPING_RULES}`);
		},
	},
	{
		version: "003",
		description: "Insert mock data for development",
		dependencies: ["001"],
		up: (db: Database) => {
			// Check if data already exists to avoid duplicates
			const result = db.exec(
				`SELECT COUNT(*) as count FROM ${TABLE_NAMES.TAG}`
			);
			const count = result[0]?.values[0]?.[0] as number;

			if (count > 0) {
				console.log("Mock data already exists, skipping insertion");
				return;
			}

			// Insert mock data for development/testing
			const mockData = [
				{
					createdTime: "2024-01-15T10:30:00Z",
					requestId: "REQ-001",
					requestIdLink: "https://jira.company.com/browse/REQ-001",
					informacionAdicional: "Error en módulo de facturación",
					modulo: "Facturación",
					problemId: "PROB-001",
					problemIdLink: "https://jira.company.com/browse/PROB-001",
					linkedRequestIdValue: "REQ-001",
					linkedRequestIdLink:
						"https://jira.company.com/browse/REQ-001",
					jira: "JIRA-12345",
					categorizacion: "Bug Critical",
					technician: "Juan Pérez",
				},
				{
					createdTime: "2024-01-16T14:20:00Z",
					requestId: "REQ-002",
					requestIdLink: "https://jira.company.com/browse/REQ-002",
					informacionAdicional: "Mejora en performance del dashboard",
					modulo: "Dashboard",
					problemId: "PROB-002",
					problemIdLink: "https://jira.company.com/browse/PROB-002",
					linkedRequestIdValue: "REQ-002",
					linkedRequestIdLink:
						"https://jira.company.com/browse/REQ-002",
					jira: "JIRA-12346",
					categorizacion: "Enhancement",
					technician: "María García",
				},
				{
					createdTime: "2024-01-17T09:15:00Z",
					requestId: "REQ-003",
					requestIdLink: "https://jira.company.com/browse/REQ-003",
					informacionAdicional:
						"Integración con nuevo sistema de pagos",
					modulo: "Pagos",
					problemId: "PROB-003",
					problemIdLink: "https://jira.company.com/browse/PROB-003",
					linkedRequestIdValue: "REQ-003",
					linkedRequestIdLink:
						"https://jira.company.com/browse/REQ-003",
					jira: "JIRA-12347",
					categorizacion: "Feature Request",
					technician: "Carlos Rodriguez",
				},
			];

			// Insert mock data using prepared statement for better performance
			const insertStmt = db.prepare(`
				INSERT INTO ${TABLE_NAMES.TAG} (
					requestId, createdTime, requestIdLink, informacionAdicional,
					modulo, problemId, problemIdLink, linkedRequestIdValue,
					linkedRequestIdLink, jira, categorizacion, technician, processedAt
				) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
			`);

			try {
				mockData.forEach((data) => {
					insertStmt.run([
						data.requestId,
						data.createdTime,
						data.requestIdLink,
						data.informacionAdicional,
						data.modulo,
						data.problemId,
						data.problemIdLink,
						data.linkedRequestIdValue,
						data.linkedRequestIdLink,
						data.jira,
						data.categorizacion,
						data.technician,
					]);
				});
			} finally {
				insertStmt.free();
			}
		},
		down: (db: Database) => {
			db.run(`DELETE FROM ${TABLE_NAMES.TAG}`);
		},
	},
];
// Add more migrations here as your schema evolves

// Generate checksums for all migrations
migrations.forEach((migration) => {
	migration.checksum = generateChecksum(migration);
});

/**
 * Validate migration dependencies
 */
function validateDependencies(migrations: Migration[]): void {
	const versions = new Set(migrations.map((m) => m.version));

	for (const migration of migrations) {
		if (migration.dependencies) {
